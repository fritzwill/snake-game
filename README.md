# snake_game

c++ implementation of the classic snake game using gfx library.
Created by Tommy Lynch and Will Fritz

Implementation of classic game snake using C++. When the user starts the game, they must use the arrow keys to control the snake.  The user can make 90 degree turns in either direction.  

The user can pause the game by pressing 'p', 
resume by pressing 's', 
or quit by pressing 'q'.  

If the user eats a "food", which is the red square that appears on the screen, the snake grows by one block and the score is increased by 10.  The user loses if his snake hits itself or if it hits a the edge of the screen.  When the user loses, a game over screen appears with options to either quit with q or restart with r.

The majority of the code for this program was done in the snake.cpp file, which is the implementation of the snake class.  

In the snake.h file there are constructors to create a snake, move left, move right, move down, move up, move one space, grow, check if the food is overlapping with the snake, check if the snake hit itslef, check if the snake hit the border, set the direction, reset the game, get the value of dx and get the value of dy.  the private attributes are the xposition, y position, dx, dy, length, a struct called square(which has x position, y position, width, and height), and a deque of Squares.

In snake.cpp, the first constructor snake() creates a snake that starts in the center of the screen by intitializing a Square and pushing back the deque by that square.  snake(int x, int y) does the same thing, only the x and y position are determined by x and y.  the left, right, down, and up methods change dx and dy accordingly.  The move method creates a new square at the spot of the first square + dx +dy and pushes the front of the tail by that square while also deleting the last element using pop_back(), which makes the snake look like it is travelling fluidly.  The grow() method creates a new square at the end of the snake and pushes the deque back by that square and increases the length by 1.  The check(int x, int y) method returns a bool value by comparing the x and y values to the x and y values of each component of the deque and if any values are equal, the method returns a true value, otherwise it returns false.  The check self method checks to see if the front of the snake has hit any other part of the snake using a for loop.  the checkborder method tests to see if the x or y position of the first square is out of the border and returns a true or false value. The setChange(int x, int y) method changes the dx and dy using x and y. The reset() method clears the deque and changes the xpos, ypos, dx, dy, and length back to the original values while creating a square and pushing the deque back by that square.  The getDx() and getDy() methods return dx and dy respectively.

In final.cpp, there are two functions, newfood, and changedirection.  newfood genetates a new food square on the screen by generating a random multiple of 10 between 0 and 490 for the x and the y position, then if the xposition and y position generated are currently taken up by the snake, which is found using check() method, it generates a different random x and y until check() returns false.  Then, the color is switched to red and a rectangle is drawn using gfx_rectangle at the xposition and y position with width and height of 10 and returns an array of two ints, the first being the x position and the second being the y position.  

The changedirection functions takes the char c, which is the input from the user and gets the dx and dy values using getDx and getDy.  the function enters a switch case where it then calls different methods based upon the input. There are cases for up, down, left, right, pause, and quit.  In the main of the file, the first portion before the while loop is used to initialize variables and then open the graphics window and then create a snake. The program then enters the while loop, which is based on the value of holdLoop.  the first if statement is implemented only on the first iteration, and it is used to create the first food since if we called newfood()  outside of the if statement it would generate a new food every iteration.  

After that, the color is switched to red and then the food is actually drawn on the screen using gfx_rectangle with the first two components of the food array.  The color is then switched to white again and the bottom border is drawn along with the score and simple directions.  Then there is an if statement to check if the snake ate the food and if it returns true, the snake grows, score is incremented by 10, and a new food is created.  after this if statement, the move() method is called and then another if statement that is entered if the checkSelf() or checkBorder() method returns true, which means that the user lost the game.  In this case, the screen is cleared, "GAME OVER" is displayed along with the user's score and directions to either quit or restart. Then a while loop is entered and does not exit until the user enters 'r' or 'q' and if 'q' is entered the original while loop is exited and the game is over or if 'r' is entered the reset() method is called and score is set to 0 and then game looks like it did when it was first opened.  after this if statement, gfx_flush is called which flushes all of the grpahics to the window, and if gfx_event_waiting is true then the program gets an input from the user using gfx_wait and passes that input into changedirection.  After that if statement a while loop is entered if gfx_event_waiting is true and it calls gfx_wait(), which will clear the buffer.  Without this while loop the program would take inputs as often as you enter them, but with it it will clear the buffer every iteration so every input is taken as soon as it is entered.  Then, usleep(80000) is used to slow the program down to make it playable. 

We checked this program mostly by playing it over and over and trying to do weird things like trying to go in the opposite direction of the current direction to make sure that the program did not allow the user to do this, running into walls to see if the program would end, running into our own snake to see if the program would end, testing the pause and quit buttons mid play, and testing the quit and restart buttons after dying.  Overall, most of the testing of this code was just playing the game and giving it weird inputs and seeing what would happen.
